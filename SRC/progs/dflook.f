      program dflook
c  Copyright (C) 2015, Jerry Sellwood
      implicit none
c program to read a .dfn file and plot various properties of the particle
c   distribution it contains.  Where possible, these are checked for
c   consistency with predicted values.
c
c common blocks
c
      include 'inc/params.f'
c
      include 'inc/admin.f'
c
      include 'inc/model.f'
c
      include 'inc/orbval.f'
c
      integer krnuse, mkrn, nkrn
      parameter ( mkrn = 7000000 )
      real akrn( 3, mkrn ), hkrn
      common / kernel / krnuse, nkrn, hkrn, akrn
c
      integer mrspl, mzspl
c parameters must be ( mr + 4 ) & ( mz / 2 + 5 )
      parameter ( mrspl = 205, mzspl = 192 )
      common / splcff / nrspl, nzspl, cspl( mrspl * mzspl )
      common / spllam / lamspl( mrspl )
      common / splmu / muspl( mzspl )
      integer nrspl, nzspl
      real*8 cspl, lamspl, muspl
c
      integer nrad
      real dr, p
      common / vbins / nrad, dr, p( 1 )
c
      common / xmx / xemax
      real xemax
c
c externals
      character*4 dftype
      integer nchars
      logical gtlogl
      real*8 actj1, akappa, Emax, Emin, distfn, gmassd, gmassh!, frtot
      real*8 gsigma, gsigmi, Lzmax, Phisph, Phitot, ranuni, vcirc
      external Emax, Emaxx, Emin, Eminx, Encirc, gmassd, gmassh
      external lgsigma, lgsigmi, lrhohal, lrhohli, qtoom, qtoomi
      external sigmau, sigmui, sigmav, sigmvi, vcirc, vmean, vmeani
      external ekrn1d, ekrn2d, trans, diffE, diffL
c
c local arrays
      integer mpx, mpy, mrec, mst
      parameter ( mrec = 600, mst = 50000, mpx = 101, mpy = 101 )
      real star( mrec ), omkapp( mst ), work( mpx, mpy )
      real xp( mst ), yp( mst )
      integer necc( 101 )
      real, allocatable :: apwt( : )
c
c local variables
      character b*4, name*15
      integer i, irec, j, jplt, jst, k, kst, lrec, mplt, norb, nst, nwp
      logical actplt, contour, dfe, dfL, dblint, eccen, eLplt, explt
      logical gsurfd, Leplt, Lneg, isotrp, merid, mLplt, mrplt, omkap
      logical lpwt, qplt, retro, sigu, sigv, rho, sigz, vmplt
      real ake, f, Lscl, pwt, r, r0, tmass, x, xmn, xmx, x1, y, ymn
      real ymx, y1
      real*8 E2, L2, r2
      include 'inc/pi.f'
      parameter ( mplt = 5000 )
c
c set defaults
      call setnag
      master = .true.
      call boilrp( .true. )
      nrspl = mrspl
      nzspl = mzspl
c
    2 call gtchar( 'Enter file name (.dfn)', name )
      i = nchars( name )
      open( 1, file = name( 1:i )//'.dfn', status = 'old', err = 2,
     +      form = 'unformatted' )
      if( name( 1:3 ) .eq. 'run' )read( name( 4:i ), * )irun
c read header record
      icmp = 1
      call dfhead( 1, irec, .false., .false. )

      print *, 'after dfhead, icmp =', icmp
      print *, 'cmpmas( icmp ) =', cmpmas( icmp )
      print *, 'fmass( icmp ) =', fmass( icmp )
      print *, 'sphrod( icmp ) =', sphrod( icmp )
      print *, 'idftyp( icmp ) =', idftyp( icmp ), ' ', ctype( icmp )

c prevent interference from a different DF
      if( ncmp .gt. 1 )then
        do i = 1, ncmp
          if( i .ne. icmp )dist( i ) = .false.
        end do
      end if
c check space
      if( irec .gt. mrec )call space( mrec, irec, 'star', 28, 'DFLOOK' )
c keep point plotting to reasonable numbers
      norb = 1
      do i = 1, 3
        norb = norb * jdfcs( i, icmp )
      end do
      jplt = 1
      if( norb .gt. mplt )jplt = ( norb - 1 ) / mplt + 1
c logical flags
      retro = .false.
      if( ( cdft( icmp ) .eq. 'KALN' ) .or.
     +    ( cdft( icmp ) .eq. 'LIA ' ) )Lzrmn( icmp ) = -Lzcrt( icmp )
      Lneg = ( Lzrmn( icmp ) .lt. 0. ) .or. retract
      isotrp = ( cdft( icmp ) .eq. 'MERR' ) .or.
     +         ( cdft( icmp ) .eq. 'DEJO' ) .or.
     +         ( cdft( icmp ) .eq. 'KING' ) .or.
     +         ( cdft( icmp ) .eq. 'POLY' ) .or.
     +         ( cdft( icmp ) .eq. 'HERN' ) .or.
     +         ( cdft( icmp ) .eq. 'HNON' ) .or.
     +         ( cdft( icmp ) .eq. 'EDDI' ) .or.
     +         ( cdft( icmp ) .eq. 'DFIT' ) .or.
     +         ( cdft( icmp ) .eq. 'SISP' ) .or.
     +         ( cdft( icmp ) .eq. 'COMP' ) .or.
     +         ( cdft( icmp ) .eq. 'USPS' )
c allow for random velocities generated by Hernquist's procedure
      isotrp = isotrp .or. ( ( .not. disc( icmp ) ) .and.
     +                       ( cdft( icmp ) .eq. 'NONE' ) )
      if( idftyp( icmp ) .gt. 27 )call crash(
     +                               'DFLOOK', 'Unrecognized DF type' )
      dblint = gtlogl(
     +           'Th curves drawn from double integrals over distfn?' )
      tmass = fmass( icmp )
      if( uqmass )tmass = 1
      E2 = Phimax
      L2 = 0
      r = distfn( E2, L2 )
c initialise plot
      call jsbgn
      call jssize( 0., 1., 0., 1. )
c determine type of plot
   13 continue
      call gtchar( 'GSig, m(r), Q, vm, Evx, EvL, LvE, act, sigu, sigv,'
     +// ' merid, sigz, eccen, omkap, m(L), rho, dfE, dfL, pwt or end?',
     +  b )
      if( b( 1:3 ) .eq. 'end' )go to 21
      call lowercase( b )
      dfe = b( 1:3 ) .eq. 'dfe'
      dfL = b( 1:3 ) .eq. 'dfl'
      eccen = b .eq. 'ecce'
      eLplt = b( 1:3 ) .eq. 'evl'
      actplt = b( 1:3 ) .eq. 'act'
      explt = b( 1:3 ) .eq. 'evx'
      gsurfd = b .eq. 'gsig'
      Leplt = b( 1:3 ) .eq. 'lve'
      mLplt = b .eq. 'm(l)'
      mrplt = b .eq. 'm(r)'
      omkap = b .eq. 'omka'
      qplt = b( 1:1 ) .eq. 'q'
      sigu = b .eq. 'sigu'
      sigv = b .eq. 'sigv'
      vmplt = b( 1:2 ) .eq. 'vm'
      merid = b .eq. 'meri'
      sigz = b .eq. 'sigz'
      rho = b( 1:3 ) .eq. 'rho'
      lpwt = b( 1:3 ) .eq. 'pwt'
      contour = Leplt .or. actplt
c retrograde particles
c      if( vmplt .or. eLplt .or. sigv )then
c        print *, 'enter L_crit'
c        read *, Lcrit
c        Lzrmn = -Lcrit
c        Lneg = Lcrit .gt. 0.
c      end if
c set window
      xmn = rhole
      xmx = rtrunc( icmp )
      if( xmx .gt. 999.d0 )xmx = 20
      ymn = 0
      ymx = 1
      if( ( ctype( icmp ) .eq. 'MTZ ' ) .or.
     +    ( ctype( icmp ) .eq. 'POWE' ) )ymx = 2
      if( dfE )then
        xmx = Emaxe
        xmn = Emine
        call yrange( xmn, xmx, ymn, ymx, diffE )
      else if( dfL )then
        r2 = xmx
        xmx = r2 * vcirc( r2 )
        xmn = Lzrmn( icmp )
        call yrange( xmn, xmx, ymn, ymx, diffL )
      else if( eccen )then
        xmx = 1
        xmn = 0
        if( Lneg )xmn = -xmx
        if( ctype( icmp ) .eq. 'MTZ' )ymx = rmax
      else if( eLplt )then
        xmx = Lzmax( Emaxe )
        xmn = Lzrmn( icmp )
        if( retract .or. isotrp )xmn = -xmx
        ymx = Emaxe
        if( ctype( icmp ) .eq. 'MTZ ' )ymx = 4.
        ymn = Emine
        ymn = max( ymn, -5. )
      else if( explt )then
        xmx = 1
        xmn = 0
c        if( Lneg )xmn = -xmx
      else if( gsurfd )then
        ymx = 0
        ymn = -10
      else if( Leplt )then
        r2 = xmx
        xmx = r2 * vcirc( r2 )
        xmn = Lzrmn( icmp )
c        ymx = Emax( 0. ) - Emine
        ymx = 1.
      else if( actplt )then
        r2 = xmx
        xmx = r2 * vcirc( r2 )
        xmn = Lzrmn( icmp )
        ymx = 1.
      else if( mLplt .or. mrplt )then
        if( mLplt )then
          r2 = xmx
          xmx = r2 * vcirc( r2 )
          xmn = Lzrmn( icmp )
          if( retract )xmn = -xmx
          Lscl = 100. / ( xmx - xmn )
        end if
        if( disc( icmp ) )then
          ymx = tmass
          if( ctype( icmp ) .eq. 'MTZ ' )ymx = rmax
        else
          if( sphrod( icmp ) )then
            ymx = 1.1 * tmass
          else
            ymx = gmassh( rmax )
          end if
        end if
      else if( omkap )then
        ymx = .1
        xmx = .13
        xmn = 0
        if( Lneg )xmn = -xmx
      else if( qplt )then
        ymx = 5.
      else if( sigz )then
        ymx = .5 * xmx
        if( .not. sphrod( icmp ) )go to 13
      else if( vmplt )then
        ymx = sqrt( 2.d0 * ( Emax( 0.d0 ) - Phitot( 0.d0 ) ) )
        if( ctype( icmp ) .eq. 'MTZ ' )ymx = 2.
        if( ctype( icmp ) .eq. 'POWE' )
     +                ymx = 1.5 * max( vcirc( rhole ), vcirc( rmax ) )
        if( retro .or. isotrp .or. sphrod( icmp ) .or. Lneg )ymn = -ymx
      else if( merid )then
        ymx = xmx
        if( cdft( icmp ) .ne. 'DFIT' )ymx = xmx * dfcns( 3, icmp )
        ymn = -ymx
        if( .not. sphrod( icmp ) )go to 13
      else if( rho )then
        if( disc( icmp ) )go to 13
        ymx = 2
        ymn = -10
        xmx = log10( rmax )
        xmn = -2
      else if( .not. ( sigu .or. sigv .or. lpwt ) )then
        go to 13
      end if
c clear bins for summation
      call bin( 0. )
      do i = 1, 101
        necc( i ) = 0
      end do
c initialize pwt histogram if requested
      if( lpwt )then
        if( .not. uqmass )then
          print *, 'particles have equal masses'
          go to 13
        end if
        allocate ( apwt( norb ) )
c draw and mark axes
      else
        call jspage
        call jssize( .1, .95, .15, .85 )
        call jscale( xmn, xmx, ymn, ymx )
        if( merid )call jsescl( xmn, xmx, ymn, ymx )
        if( gsurfd .or. vmplt .or. qplt .or. sigu .or. sigv .or. mrplt
     +             .or. merid .or. sigz )call jsaxis( 'x', 'radius', 1 )
        if( dfE )call jsaxis( 'x', 'E', 1 )
        if( explt )call jsaxis( 'x', 'x', 1 )
        if( actplt )call jsaxis( 'x', 'J_{\\phi}', 1 )
        if( dfL .or.
     +           Leplt .or. eLplt .or. mLplt )call jsaxis( 'x', 'L', 1 )
        if( eccen )call jsaxis( 'x', 'eccentricity', 1 )
        if( omkap )call jsaxis( 'x', '\\Omega-\\kappa/2', 1 )
c     
        if( dfE )call jsaxis( 'y', 'F(E)dE', 1 )
        if( dfL )call jsaxis( 'y', 'F(L)dL', 1 )
        if( eLplt .or. explt )call jsaxis( 'y', 'E', 1 )
        if( gsurfd )call jsaxis( 'y', 'ln\\Sigma', 1 )
        if( Leplt )call jsaxis( 'y', 'energy of non-circular motion', 1)
        if( actplt )call jsaxis( 'y', 'J_R', 1 )
        if( qplt )call jsaxis( 'y', 'Q', 1 )
        if( vmplt )call jsaxis( 'y', 'v', 1 )
        if( merid )call jsaxis( 'y', 'z', 1 )
        if( sigu )call jsaxis( 'y', '\\sigma_u', 1 )
        if( sigv )call jsaxis( 'y', '\\sigma_v', 1 )
        if( sigz )call jsaxis( 'y', '\\sigma_z', 1 )
        if( mLplt )then
          if( isotrp )then
            call jsaxis( 'y', 'm(|L|)', 1 )
          else
            call jsaxis( 'y', 'm(L)', 1 )
          end if
        end if
        if( mrplt )call jsaxis( 'y', 'm(r)', 1 )
        if( eccen .or. omkap )call jsaxis( 'y', 'mass fraction', 1 )
        if( rho )then
          call jslaxs( 'x', 'r', 1 )
          call jslaxs( 'y', '\\rho', 1 )
        end if
      end if
c
c read in particles
      lrec = 0
      nst = 0
      jst = 0
      kst = 0
      nkrn = 0
      k = 0
      nwp = 3
      if( sphrod( icmp ) )nwp = 4
      if( uqmass )nwp = nwp + 1
    1 if( k + nwp .gt. lrec )then
        lrec = nwp * ( norb - nst )
        lrec = min( irec, lrec )
        if( lrec .eq. 0 )go to 3
        read( 1, end = 3, err = 3 )( star( i ), i = 1, lrec )
c        if( Lcrit .gt. 0.d0 )then
c          do i = 1, lrec, 3
c            call retset( star( i ), star( i + 2 ) )
c          end do
c        end if
c        print *, nst, ' done', lrec / nwp, ' read in'
        k = 0
      end if
      ri = star( k + 1 )
      ui = star( k + 2 )
      vi = star( k + 3 )
      if( sphrod( icmp ) )zi = star( k + 4 )
      pwt = cmpmas( icmp )
      if( uqmass )pwt = cmpmas( icmp ) * star( k + nwp )
      k = k + nwp
      nst = nst + 1
      if( lpwt )then
        apwt( nst ) = pwt
        go to 1
      end if
c retrograde particles
      if( vmplt .or. sigv )then
        if( retro .or. sphrod( icmp ) )then
          if( ranuni( 0. ) .lt. .5d0 )vi = -vi
        end if
      end if
c remember total angular momentum
      L2 = ri * vi
      if( mLplt )then
        if( mod( nst, jdfcs( 3, icmp ) ) .ne. 0 )go to 1
        y = Lscl * ( sngl( L2 ) - xmn )
        j = y
        j = j + 1
        necc( j ) = necc( j ) + jdfcs( 3, icmp )
        go to 1
      end if
c resolve orbital velocity into only relevant component
      if( isotrp )then
        x = 2. * pi * ranuni( 0. )
        vi = vi * sin( x )
      end if
c radial velocities
      if( sphrod( icmp ) .and. sigu )then
        x = 2. * pi * ranuni( 0. )
        ui = ui * sin( x )
      end if
c accumulate means etc
      if( mrplt )ri = sqrt( ri**2 + zi**2 )
      call bin( pwt )
      if( gsurfd .or. qplt .or. mrplt .or.
     +    sigu .or. sigv .or. sigz .or. rho )go to 1
      if( jst .eq. mst )then
        call jsymbl( xp, yp, jst, 0 )
        jst = 0
      end if
c orbital velocity plot
      if( vmplt .or. merid )then
        if( mod( nst, jplt ) .eq. 0 )then
          jst = jst + 1
          xp( jst ) = ri
          yp( jst ) = vi
          if( merid )yp( jst ) = zi
        end if
        go to 1
      end if
      if( mod( nst, jdfcs( 3, icmp ) ) .ne. 0 )go to 1
c energy/ang mom plot
      if( sphrod( icmp ) )then
        E2 = .5 * ( ui * ui + vi * vi ) + Phisph( ri, zi )
      else
        E2 = .5 * ( ui * ui + vi * vi ) + Phitot( ri )
      end if
      if( dfE )then
        if( mod( nst, jdfcs( 3, icmp ) ) .ne. 0 )go to 1
        nkrn = nkrn + 1
        if( nkrn .gt. mkrn )call crash( 'DFLOOK', 'Increase mkrn' )
        akrn( 1, nkrn ) = E2
        go to 1
      end if
      if( dfL )then
        if( mod( nst, jdfcs( 3, icmp ) ) .ne. 0 )go to 1
        nkrn = nkrn + 1
        if( nkrn .gt. mkrn )call crash( 'DFLOOK', 'Increase mkrn' )
        akrn( 1, nkrn ) = L2
        go to 1
      end if
      if( eLplt )then
        L2 = ri * vi
        jst = jst + 1
        xp( jst ) = L2
        yp( jst ) = E2
        go to 1
      end if
      if( Leplt .or. actplt )then
        if( contour )then
          if( sngl( L2 ) .gt. xmn .and. sngl( L2 ) .lt. xmx )then
            nkrn = nkrn + 1
            if( nkrn .gt. mkrn )call crash( 'DFLOOK', 'Increase mkrn' )
            akrn( 1, nkrn ) = L2
            if( Leplt )then
              akrn( 2, nkrn ) = E2 - Emin( L2 )
            else
              akrn( 2, nkrn ) = actJ1( E2, L2 )
            end if
          end if
        else
          jst = jst + 1
          xp( jst ) = L2
          if( Leplt )then
            yp( jst ) = E2 - Emin( L2 )
          else
            yp( jst ) = actJ1( E2, L2 )
          end if
        end if
        go to 1
      end if
c energy/x plot
      if( explt )then
        jst = jst + 1
        xp( jst ) = -abs( L2 ) * sqrt( -2. * E2 ) * rstar
        yp( jst ) = -E2
        go to 1
      end if
c omega - .5 * kappa distribution
      if( omkap )then
        call omegas( L2, E2 )
        x = abs( omega2 ) - .5 * omega1
        kst = kst + 1
        if( kst .gt. mst )call crash( 'DFLOOK', 'omkapp too small' )
        omkapp( kst ) = x
        i = 384.616 * x
        if( vi .lt. 0. )i = 1 - i
        if( abs( i ) .lt. 51 )necc( i + 51 ) = necc( i + 51 ) +
     +                                                  jdfcs( 3, icmp )
        go to 1
      end if
c eccentricity distribution
      if( vi .gt. 0. )call rlims( L2, E2 )
      y = 1.
      if( vi .gt. 0. )y = ( rapo - rperi ) / ( rapo + rperi )
      j = 20. * y
      j = min( 20, j + 1 )
      necc( j ) = necc( j ) + jdfcs( 3, icmp )
      go to 1
c histogram particle weights
    3 if( lpwt )then
        call jssize( .1, .9, .1, .85 )
        call jshist( apwt, nst )
        deallocate ( apwt )
        xmn = 0
        xmx = 1
        ymn = 0
        ymx = 1
        call jscale( xmn, xmx, ymn, ymx )
      end if
c complete point plot if necessary
      if( jst .gt. 0 )call jsymbl( xp, yp, jst, 0 )
      if( dfE )then
        call jsdash( 2, 2, 2, 2 )
        call jsplt2( diffE )
        call jsdash( 0, 0, 0, 0 )
        hkrn = 0.01
        call jsplot( ekrn1D )
      end if
      if( dfL )then
        call jsdash( 2, 2, 2, 2 )
        call jsplt2( diffL )
        call jsdash( 0, 0, 0, 0 )
        hkrn = 0.01
        call jsplot( ekrn1D )
      end if
      if( contour )then
        hkrn = .1
        if( Leplt .or. actplt )then
          jst = nkrn
          do i = 1, jst
            if( akrn( 2, i ) .lt. hkrn )then
              nkrn = nkrn + 1
              if( nkrn .gt. mkrn )call crash('DFLOOK', 'Increase mkrn' )
              akrn( 1, nkrn ) = akrn( 1, i )
              akrn( 2, nkrn ) = -akrn( 2, i )
            end if
            if( akrn( 1, i ) .lt. xmn + hkrn )then
              nkrn = nkrn + 1
              if( nkrn .gt. mkrn )call crash('DFLOOK', 'Increase mkrn' )
              akrn( 1, nkrn ) = akrn( 1, i ) - hkrn
              akrn( 2, nkrn ) = akrn( 2, i )
            end if
          end do
        end if
        call rskern( .true. )
        call jsctrf( ekrn2d, 10, work, mpx, mpy, trans, .true. )
        call rskern( .false. )
      end if
c write picture header
      if( cdft( icmp ) .eq. 'KALN' )call jsbldt( 'Kalnajs DF' )
      if( cdft( icmp ) .eq. 'LIA ' )call jsbldt( 'Lia DF for KT disc' )
      if( cdft( icmp ) .eq. 'MIYA' )call jsbldt(
     +                                       'Miyamoto DF for KT disc' )
      if( cdft( icmp ) .eq. 'ZANG' )call jsbldt(
     +                                      'Zang DF for V=const disc' )
      if( cdft( icmp ) .eq. 'OMEG' )call jsbldt( 'Omega model' )
      if( cdft( icmp ) .eq. 'MERR' )call jsbldt(
     +                                    'Merritt DF for Jaffe model' )
      if( cdft( icmp ) .eq. 'DEJO' )call jsbldt(
     +                                'Dejonghe DF for Plummer sphere' )
      if( cdft( icmp ) .eq. 'LUCY' )call jsbldt( 'Lucy' )
      if( cdft( icmp ) .eq. 'NEIL' )call jsbldt( 'Neil' )
      if( cdft( icmp ) .eq. 'CPB0' )call jsbldt(
     +                                         'Composite \\Omega B_0' )
      if( cdft( icmp ) .eq. 'KING' )call jsbldt( 'King model' )
      if( cdft( icmp ) .eq. 'POLY' )call jsbldt( 'Spherical polytrope' )
      if( cdft( icmp ) .eq. 'EDDI' )then
        call jsbldt( 'Eddington inversion for' )
        if( ctype( icmp ) .eq. 'NFW ' )call jsbldt( 'NFW' )
        if( ctype( icmp ) .eq. 'EINA' )call jsbldt( 'Einasto' )
        call jsbldt( 'halo' )
      end if
      if( cdft( icmp ) .eq. 'EVAN' )call jsbldt( 'Evans power law' )
      if( cdft( icmp ) .eq. 'DJDZ' )call jsbldt( 'Dejonghe-deZeeuw DF' )
      if( cdft( icmp ) .eq. 'EVCO' )call jsbldt(
     +                                     'Evans DF for Rybicki disc' )
      if( cdft( icmp ) .eq. 'SAWA' )call jsbldt(
     +                               'Sawamura DF for polynomial disc' )
      if( cdft( icmp ) .eq. 'HERN' )call jsbldt( 'Hernquist DF' )
c
      if( cdft( icmp ) .eq. 'KING' )then
        call jsbldt( '\\Phi_0 =' )
        call jsbldf( dfcns( 3, icmp ), 8, 3 )
      else if( cdft( icmp ) .eq. 'COMP' )then
        do i = 1, ncomp
          if( iccmp( i ) .eq. icmp )j = i
        end do
        call jsbldt( 'Compressed '// dftype( idfn0( j ) ) // ' par =' ) 
        call jsbldf( sngl( dfm0( j ) ), 8, 3 )
      else if( ( cdft( icmp ) .ne. 'CPB0' ) .and.
     +         ( cdft( icmp ) .ne. 'EDDI' ) .and.
     +         ( cdft( icmp ) .ne. 'HERN' ) )then
        call jsbldt( 'par =' )
        call jsbldf( dfcns( 1, icmp ), 8, 3 )
      end if
      x1 = .8 * xmn + .2 * xmx
      y1 = 1.1 * ymx - .1 * ymn
      call jswrit( x1, y1 )
      if( ( Lzcrt( icmp ) .ne. 0.d0 ) .and. .not. 
     +    ( ( cdft( icmp ) .eq. 'ZANG' ) .or.
     +      ( cdft( icmp ) .eq. 'EVAN' ) ) )then
        call jsbldt( 'L_{crit} =' )
        call jsbldf( sngl( Lzcrt( icmp ) ), 5, 2 )
      end if
      if( retract )call jsbldt( 'Kalnajs retro rule' )
      call jsbldi( nst, 8 )
      call jsbldt( 'particles' )
      x1 = .7 * xmn + .3 * xmx
      y1 = 1.05 * ymx - .05 * ymn
      call jswrit( x1, y1 )
c
      if( dfE .or. dfL .or. lpwt )go to 20
      if( omkap .or. merid )go to 24
      if( gsurfd .or. mrplt .or. vmplt .or. sigu .or. sigv .or.
     +    qplt .or. sigz .or. rho )go to 16
      if( Leplt .or. eLplt .or. explt .or. actplt )go to 8
c eccentricity distribution
      if( eccen )then
        j = 0
        do i = 1, 10
          j = j + necc( i )
        end do
        f = tmass * real( j ) / real( norb )
        call jsbldt( 'w.5' )
        call jsbldf( f, 6, 4 )
        call jswrit( .1, .9 )
        call jsmove( 0., 0. )
        y = 0.
        x = 0.
        do i = 1, 20
          y = y + tmass * real( necc( i ) ) / real( norb )
          call jsline( x, y )
          x = .05 * real( i )
          call jsline( x, y )
        end do
        go to 20
      end if
c angular momentum distribution
      if( mLplt )then
        call jsmove( 0., 0. )
        y = 0.
        x = xmn
        do i = 1, 100
          y = y + tmass * real( necc( i ) ) / real( norb )
          call jsline( x, y )
          x = xmn + real( i ) / Lscl
          call jsline( x, y )
        end do
        go to 20
      end if
c plot distribution of omega - kappa / 2
   24 j = 51
      if( Lzcrt( icmp ) .gt. 0. )j = 1
      x = .0026 * real( j - 51 )
      call jsmove( x, 0. )
      do i = j, 100
        y = real( necc( i ) ) / real( norb )
        call jsline( x, y )
        x = .0026 * real( i - 50 )
        call jsline( x, y )
      end do

      print *, kst, norb
      call jshist( omkapp, kst )

      go to 20
c draw desired curve
   16 call bin( -1. )
      ake = 0.
      r0 = rhole
      do i = 1, nrad
        r = rhole + dr * real( i )
        xp( i ) = r - .5 * dr
        j = ( i - 1 ) * 7
        f = p( j + 1 ) * tmass / real( norb )
        if( gsurfd )then
          if( f .eq. 0. )then
            yp( i ) = ymn
          else
            yp( i ) = log( f / ( pi * ( r**2 - r0**2 ) ) )
          end if
          r0 = r
        else if( rho )then
          if( f .eq. 0. )then
            yp( i ) = ymn
          else
            yp( i ) = log10( 3. * f / ( 4. * pi * ( r**3 - r0**3 ) ) )
          end if
          xp( i ) = log10( r - .5 * dr )
          r0 = r
        else if( mrplt )then
          if( i .eq. 1 )then
            yp( 1 ) = f
          else
            yp( i ) = yp( i - 1 ) + f
          end if
          xp( i ) = r
        else
          ake = ake + f * p( j + 2 )**2
          if( qplt )then
            r2 = xp( i )
            if( dblint )then
            yp( i ) = p( j + 5 ) * akappa( r2 ) / ( 3.36*gsigmi( r2 ) )
            else
            yp( i ) = p( j + 5 ) * akappa( r2 ) / ( 3.36*gsigma( r2 ) )
            end if
          end if
          if( vmplt )yp( i ) = p( j + 2 )
          if( sigv )yp( i ) = p( j + 3 )
          if( sigu )yp( i ) = p( j + 5 )
          if( sigz )yp( i ) = p( j + 7 )
        end if
      end do
      call jsjoin( xp, yp, nrad )
      if( sigz )go to 20
c draw circular velocity curve
      if( vmplt )then
        ake = .5 * ake
        call jsbldt( 'KE of rotation' )
        call jsbldf( ake, 7, 4 )
        call jswrit( .7 * xmx, .9 * ymx )
        call jsdash( 3, 2, 1, 2 )
        call jsplt2( vcirc )
      end if
c draw theoretical curves
      call jsdash( 2, 2, 2, 2 )
      if( mrplt )then
        if( disc( icmp ) )then
          call jsplt2( gmassd )
        else
          if( .not. sphrod( icmp ) )call jsplt2( gmassh )
        end if
      else
        if( dblint )then
          if( rho )call jsplt2( lrhohli )
          if( gsurfd )call jsplt2( lgsigmi )
          if( qplt )call jsplt2( qtoomi )
          if( sigu )call jsplt2( sigmui )
          if( sigv )call jsplt2( sigmvi )
          if( vmplt )call jsplt2( vmeani )
          call jsdash( 0, 1, 0, 1 )
        end if
        if( gtlogl( 'Plot theoretical curve?' ) )then
          if( gsurfd )call jsplt2( lgsigma )
          if( vmplt )call jsplt2( vmean )
          if( sigu )call jsplt2( sigmau )
          if( sigv .and.
     +        ( cdft( icmp ) .ne. 'LUCY' ) )call jsplt2( sigmav )
          if( rho )call jsplt2( lrhohal )
          if( qplt )then
            call jsplt2( qtoom )
            if( ( cdft( icmp ) .ne. 'SHUE' ) )call qvals
          end if
        end if
      end if
      call jsdash( 0, 0, 0, 0 )
      go to 20
c draw boundaries
    8 if( eLplt )then
        call jsplt2( Emax )
        call jsplt2( Emin )
      end if
      if( explt )then
        call jsplt2( Emaxx )
        call jsplt2( Eminx )
      end if
      if( Leplt )call jsplt2( Encirc )
c rewind file and skip forward over header
   20 rewind 1
      do i = 1, ncmp + 1
        read( 1 )
      end do
      go to 13
   21 continue
      call jsend
      stop
      end

      real*8 function Encirc( L )
      implicit none
c
c calling argument
      real*8 L
c
c externals
      real*8 Emax, Emin
c
      Encirc = Emax( L ) - Emin( L )
      return
      end

      subroutine qvals
      implicit none
c
c common block
c
      include 'inc/params.f'
c
      include 'inc/model.f'
c
c externals
      real*8 gmassd, qtoom
c
c local variables
      integer i
      real q, qcen, qmean1, qmean2, qroot2
      real*8 dr, r, r1, r2
c
      qmean1 = 0.
      qmean2 = 0.
      dr = .02 * ( rmax - rhole )
      r1 = rhole
      do i = 1, 51
        r = rhole + dr * real( i - 1 )
        r2 = r + .5 * dr
        q = qtoom( r )
        if( i .eq. 1 )qcen = q
        if( i .eq. 11 )qroot2 = q
        qmean1 = qmean1 + q * ( gmassd( r2 ) - gmassd( r1 ) )
        r1 = r2
        if( i .eq. 11 )qmean2 = qmean1 / gmassd( r2 )
      end do
      qmean1 = qmean1 / gmassd( r2 )
      call jsbldt( 'Q_{cen}' )
      call jsbldf( qcen, 5, 2 )
      call jswrit( .5, 4.5 )
      call jsbldt( 'Q_{root2}' )
      call jsbldf( qroot2, 5, 2 )
      call jswrit( .5, 4. )
      call jsbldt( 'Mean Q from 0 to 6' )
      call jsbldf( qmean1, 5, 2 )
      call jswrit( .5, 3.5 )
      call jsbldt( 'Mean Q from 0 to root2' )
      call jsbldf( qmean2, 5, 2 )
      call jswrit( .5, 3. )
      return
      end

      subroutine bin( pwt )
      implicit none
c
c calling argument
      real pwt
c
c common blocks
c
      include 'inc/params.f'
c
      include 'inc/model.f'
c
      include 'inc/orbval.f'
c
      integer mrad, nrad
      parameter ( mrad = 500 )
      real dr, p
      common / vbins / nrad, dr, p( 7 * mrad )
c
c local variables
      integer i, j
      real a
c
      if( pwt .gt. 0. )then
        j = ( ri - rhole ) / dr
        if( j .ge. nrad )return
        j = j * 7
        p( j + 1 ) = p( j + 1 ) + pwt
        p( j + 2 ) = p( j + 2 ) + pwt * vi
        p( j + 3 ) = p( j + 3 ) + pwt * vi * vi
        p( j + 4 ) = p( j + 4 ) + pwt * ui
        p( j + 5 ) = p( j + 5 ) + pwt * ui * ui
        p( j + 6 ) = p( j + 6 ) + pwt * zi
        p( j + 7 ) = p( j + 7 ) + pwt * zi * zi
      else if( pwt .eq. 0 )then
c clear bins
        nrad = mrad
        a = rmax
        if( rmax .gt. 999.d0 )a = 20
        dr = ( a - rhole ) / real( nrad )
        do i = 1, 7 * nrad
          p( i ) = 0.
        end do
      else
c evaluate moments
        do i = 1, nrad
          j = ( i - 1 ) * 7
          a = p( j + 1 )
          if( a .gt. 0. )then
            p( j + 2 ) = p( j + 2 ) / a
          p( j + 3 ) = ( p( j + 3 ) - a * p( j + 2 ) * p( j + 2 ) ) / a
            p( j + 3 ) = max( p( j + 3 ), 0. )
            p( j + 3 ) = sqrt( p( j + 3 ) )
            p( j + 4 ) = p( j + 4 ) / a
          p( j + 5 ) = ( p( j + 5 ) - a * p( j + 4 ) * p( j + 4 ) ) / a
            p( j + 5 ) = max( p( j + 5 ), 0. )
            p( j + 5 ) = sqrt( p( j + 5 ) )
            p( j + 6 ) = p( j + 6 ) / a
          p( j + 7 ) = ( p( j + 7 ) - a * p( j + 6 ) * p( j + 6 ) ) / a
            p( j + 7 ) = max( p( j + 7 ), 0. )
            p( j + 7 ) = sqrt( p( j + 7 ) )
          end if
        end do
      end if
      return
      end

      real*8 function dfwght( E, L )
c function to weight DF when unequal particle masses are requested
      implicit none
c
c calling arguments
      real*8 E, L
c
c dummy version for when  particle weights are already set
      dfwght = 1.
      return
      end

      real*8 function diffE( E )
      implicit none
c
c calling argument
      real*8 E
c
c common blocks
c
      include 'inc/params.f'
c
      include 'inc/model.f'
c
c externals
      real*8 Lzmax, Lzmin, sglint
c
c local variables
      real*8 L1, L2
c
      L2 = Lzmax( E )
      L1 = max( -L2, Lzrmn( icmp ) )
      if( L1 .eq. 0. )L1 = Lzmin( E )
      diffE = sglint( L1, L2, E )
      return
      end

      real*8 function diffL( L )
      implicit none
c
c calling argument
      real*8 L
c
c common blocks
c
      include 'inc/params.f'
c
      include 'inc/model.f'
c
      real*8 Ecut, Lc
      common / cut / Ecut, Lc
c
c externals
      external dfnjh
      real*8 Emax, Emin, quad_gnr
c
c local variables
      integer ier
      real*8 E1, E2, epsa, epsr
c
      Lc = L
      E1 = Emin( L )
      E2 = Emax( L )
c integrate over E at fixed L
      epsa = 1.d-5
      epsr = epsa
      diffL = quad_gnr( dfnjh, E1, E2, epsa, epsr, ier )
      if( ier .ne. 0 )then
        if( ier .eq. 2 )then
          print *,
     +        'Cannot achieve reqested accuracy due to roundoff errors'
        else
          print *, 'ier =', ier, ' from QUAD_GNR'
          call crash( 'SGLINT', 'QUADPACK error' )
        end if
      end if
      return
      end

      real*8 function dfnjh( E )
      implicit none
c
c calling argument
      real*8 E
c
c common blocks
c
      include 'inc/params.f'
c
      real*8 Ec, Lc
      common / cut / Ec, Lc
c
      include 'inc/model.f'
c
c externals
      real*8 distfn, satab, tautab
c
c local variable
      include 'inc/pi.f'
c
c DFs for flattened spheroids
      if( sphrod( icmp ) )then
        dfnjh = 4 * pi**2 * satab( E, Lc ) * distfn( E, Lc )
      else if( dist( icmp ) )then
c DFs for discs
        dfnjh = 2. * pi * tautab( E, Lc ) * distfn( E, Lc )
c extra factor for spheres
        if( .not. disc( icmp ) )dfnjh = 4. * pi * Lc * dfnjh
      else
        call crash( 'DFNJE', 'Unknown DFTYPE' )
      end if
      return
      end
